/*
조합의 경우수(메모이제이션)

로 계산합니다. 하지만 여러분은 이 공식을 쓰지않고 다음 공식을 사용하여

재귀를 이용해 조합수를 구해주는 프로그램을 작성하세요.


▣ 입력설명 첫째 줄에 자연수 n(3<=n<=33)과 r(0<=r<=n)이 입력됩니다.

▣ 출력설명 첫째 줄에 조합수를 출력합니다.
*/



function solution(n, r){ 
    let answer;
    let val = 1;    
    function DFS(n,r){
        if(n<r){
            return;
        }else{
            val = val*n
            DFS(n-1,r)
            console.log(`n의값 :  ${n}  val의 값 : ${val}`); 
            // 결국 스택 구조로 됨 값을 정확히 리턴하려면 조건에 달성했을때 값을 넘기는 방법이 필요함
        }
    }
    DFS(n,r)
    let temp1 = val;
    val = 1;
    DFS(r,1);
    let temp2 = val;
    answer = temp1 / temp2;
    return answer;
}

console.log(solution(5, 3));


/*
재귀 함수를 사용했을 때의 단점
위에서 살펴봤듯이 재귀 함수를 사용하면 함수의 호출이 스택에 차곡 차곡 쌓이게 되고, 위에서부터 차례대로 값을 반환하기 전에는 계속 메모리 공간을 차지하고 있다. 그렇기 때문에 호출 스택이 너무 커져서 메모리를 엄청나게 소비할 수도 있다. 이러한 이유 때문에 재귀를 사용하는 것보다 반복문을 사용했을 때 더 성능이 좋은 경우가 많다. 그러므로 상황에 따라 적절한 방법을 골라서 사용할 수 있어야 한다.
*/